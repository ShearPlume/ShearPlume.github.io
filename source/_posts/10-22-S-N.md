---
title: 10.22 S&N
date: 2022-10-24 22:27:36
tags:
- course
- S&N
---

# Sigma16 汇编语言

## 格式

一个Sigma16汇编语言程序由汇编语言语句和汇编指令的列表组成，每行一个。

一条汇编语言语句正好指定一条机器码指令，由4个字段组成，中间至少有一个空格，格式如下。

![image-20221024223351555](10-22-S-N/image-20221024223351555.png)

Label可以是由程序员选择的任何名称。通常情况下，只有当某一行将被另一条指令引用时才会被标注，标签总是从第一列开始。如果没有标签，第一个字符应该是空格

Mnemonic（助记符）指令的简称（如ADD、SUB等）。

Operand field段列出指令所需的其他信息（操作数在哪里，结果在哪里）。

可选的comment field字段总是以"；"字符开头（解释汇编语言）

对于RRR来说，Operand field总是列出3个寄存器Rd,Ra,Rb（按顺序），用逗号分开。==即使在不需要3个寄存器的情况下也会使用这种形式==。RRR的汇编语句形式：

![image-20221024225207926](10-22-S-N/image-20221024225207926.png)

这条指令的意思是读取R1中的内容，并将其按位反转，将结果存在R3中，R0被忽略（不一定是R0可以是其他急促你，不重要）

在S16汇编语言中，前面有\$的数字是十六进制的。不加\$则为十进制。因此，100\$是$$100_{10}$$，也就是10进制下的256。

==汇编伪指令（assembler directive==）并没有被翻译成机器码，而是给汇编程序的一个指令，用来做一些事情。**作用主要是对汇编过程进行控制**。最常见的例子是DATA指令，它允许将数据预设在特定的内存中。这个指令的汇编格式如下：

![image-20221024230013751](10-22-S-N/image-20221024230013751.png)

意思是给下一个可用的内存位置打上x的标签，并将其初始化为16进制3000，x现在可以被当 b作一个（16位）变量的名称。（很像高级语言中的声明变量）

## RX族（区别于RRR）

RX指令有6条

![image-20221024235533990](10-22-S-N/image-20221024235533990.png)

RX指令由两个16位的字组成，第一个字有四个字段：op,d,a,b,所有RX指令的op位都是15（f）,第二个字（auxiliary word辅助字）是一个单独的16位字，称作位移（displacement），第一个字中的b字段唯一决定了此RX的实际指令，这种转义的操作被称为“==拓展操作码==（expanding op-code）”

RX指令只需要两个寄存器，因此d，a是有用的，b用于保存操作码的拓展

每条RX指令读取两个参数：X和R

第一个参数使用寄存器相对寻址（indexed addressing），是将一个在a字段表示的寄存器中的内容和一个叫做位移displacement的16位常数相加（也就是第二个字里的内容）

RX指令的汇编格式如下：

![image-20221025001202613](10-22-S-N/image-20221025001202613.png)

Rd所在位置叫目标寄存器，虽然在STORE指令里这块是数据的来源，但它还时间目标寄存器

### X指令

X格式是RX格式的一个特例，它只有一个操作数，是一个索引的地址。在机器语言中，X格式的指令在d字段（目标寄存器）有一个 "不在乎 "的值，可以被设为0。跳跃指令就是唯一以X格式作为格式的指令，b字段是3

![image-20221025001621485](10-22-S-N/image-20221025001621485.png)

由于希望能存取更多的数据，因此从内存读数据到寄存器和从寄存器写数据到内存都很重要

#### LOAD指令

![image-20221030184606667](10-22-S-N/image-20221030184606667.png)

 后者是寄存器相对寻址**R0内容+1024**即地址为1024的内容

#### STORE指令

把第一个操作数寄存器内容存储在第二个操作数的数字+第三个操作数寄存器的内容的和表达的地址上

![image-20221030190420790](10-22-S-N/image-20221030190420790.png)

#### LEA（Load Effective Address）

它计算出第二个操作数的有效地址，并将该地址（而不是其内容）加载到作为其第一个操作数的寄存器中。如下：

![image-20221030190555823](10-22-S-N/image-20221030190555823.png)

表示把R0内容（0）+ “1024”存到R1里

使用

TRAP R0,R0,R0	 来结束一个程序

例子：把30+31存在地址100里：

![image-20221030191926775](10-22-S-N/image-20221030191926775.png)

把30地址和31地址内容相加存在地址100里：

![image-20221030192445064](10-22-S-N/image-20221030192445064.png)

这种方法很笨拙，不像高级语言里面可以直接给变量名，编译器自己找地址，但其实可以用DATA指令实现这种效果，之后会讲

#### Booleans

Sigma16用一个16位数据表示boolean，浪费但是方便cpu处理，0是False，其他都是True

#### 比较指令Compares：

##### CMPLT（compare if less than）：（两个数都以补码表示）

![image-20221030194028799](10-22-S-N/image-20221030194028799.png)

如果R2<R3,把1存入R1，否则把0存入R1

##### CMPGT（compare if greater than）：（两个数都以补码表示）

##### CMPEQ（compare if equal to）：（不用补码表示，值判断是否一样）

#### 跳转指令Jumps：

##### JUMPF：

![image-20221030195034137](10-22-S-N/image-20221030195034137.png)

如果R1里是0，跳转到mem（x+R2），否则什么都不做转而执行下条指令

##### JUMPT：

和上条差不多，条件反过来



比较指令经常与跳转指令结合使用，例子：



