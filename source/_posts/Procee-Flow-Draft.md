---
title: Procee Flow Draft
date: 2023-02-03 15:00:21
tags:
- courses
- IT Project
---

### 1.游戏开始

1.玩家在浏览器页面点击游戏开始按钮，此时前端从服务端尝试获取HTNL和JS文件

2.一个GameController Java类被激活，Result函数被调用，返回游戏页面的html网页文件，游戏页面在浏览器中被显示

3.GameController调用openWebsocketConnection（）函数，并返回GameScreenController调用Socket函数，完成网络套接字连接的创建，接着创建一个新的GameActor，此GameActor负责接收和处理游戏内的消息

4.Actor的构造函数内依次完成对前端消息和对应执行函数关联的哈希表的建立，接着创建GameState对象来存储一些表示游戏状态的bool变量，接着创建集合ImageListPreload，来加载美术资源的配置文件。完成上述内容后，Actor向前端发送一个ActorReady消息，并把ImageListPreload集合发给前端，并同时根据配置文件加载美术资源。

最后actor进入被动接受消息状态，等待前端消息以做出对应反应类内的EventProcessor（）函数

5.前端在完成美术资源加载后，向后端发送intialize消息

后端收到initialize消息后，调用initialize类中的EventProcessor

此函数应包含以下内容：

使用sethealth和setmana函数设置玩家和ai的初始生命和法力值

创建unit的arrylist，初始size为1

将unitlist的内容分配为avatar unit

将avatar unit的生命设置为玩家生命初始值20

创建tile数组

使用drawcard函数绘制tile

创建卡牌arraylist，初始容量为3

随机分配三张手牌给arrlist

使用drawcard函数在前三章手牌槽绘制手牌

###  2.玩家回合

#### 玩家打牌

1.检查GameState，若playcard为true，开启对卡牌消息的监听，否则所有卡牌置为灰色，对玩家鼠标状态不做反应，在监听状态下：

2.当玩家鼠标悬浮在卡牌槽中某个卡牌上但未点击时，向后端发送cardfloated消息，此消息包括鼠标悬浮卡牌的标号（0到5）

3.后端接收到cardfloated消息后，调用对应类的proces函数，此函数应包括：

​	3.1根据标号将卡牌arraylist中对应卡牌使用cardhighlight高亮函数

4.玩家鼠标移走后，向后端发送stopfloat消息

5.后端接收消息后，调用对应类的proces函数，此函数应包括：

​	5.1遍历arraylist，将所有卡牌解除高亮

6.当玩家鼠标悬浮在某张卡牌上并点住鼠标左键不松开时，向后端发送cardselected消息，此消息包括鼠标点中的卡牌的标号（0到5）

7.后端接收到cardselected消息后，调用对应类的proces函数，此函数应包括：

​	7.1将对应编号卡牌置为红色（redhighlighted）

​	7.2根据此手牌类型（召唤或法术），遍历tile数组，将能释放卡牌的tile进行高亮（tilehighlighted）

8.当玩家把点选中的卡牌拖动到允许释放的tile上并松开左键后，向后端发送cardreleased消息

9.后端接收到cardreleased消息后，调用对应类的proces函数，此函数应包括：

​	9.1若是召唤卡牌被释放，应根据card信息，创建unit对象，add进unitlist，并使用drawunit在对应tile绘制unit

​	9.2若是法术卡牌被释放，根据card信息，调用对应的effect函数，绘制特效，并对被产生效果的单位进行对应的数据修改（比如hp减少），若受影响的unit状态达到阈值（比如hp清零），需要对对应unit进行相关操作（remove）

​	9.3更改gamestate，将playcard置为false

#### 玩家移动单位和攻击目标

1 玩家结束出牌阶段，进入控制单位和攻击目标阶段。 

2 玩家单击一个在棋盘上的单位。 

3 这将会触发一个判断，判断这个单位是否由玩家控制，如果不是，则会向界面发送消息，表明这不是玩家的单位，玩家将无法控制。 

4 如果这个单位由玩家控制，则会进入下一个判断，判断这个单位是否能够行动，是会调unit的active属性进行判断，如果该单位在本回合不具有行动能力，则会像界面发送消息，告诉玩家这个单位在本回合内无法行动。 

5 如果选中的单位是由玩家控制且在本回合能够行动，将会在界面中用高光表示出可以移动的范围。 

6 该棋子可移动的范围将进行寻路算法计算，因为大部分的单位只能够移动两步，可以使用广度优先搜索的方法对进行寻路。对于飞行单位，因为他们可以移动任意步数，只有在极其特殊的情况下才会无法到达地图的任意位置，所以对飞行单位使用深度优先搜索的方法进行寻路。 

7 在显示可移动的范围之后，玩家可以点击将要移动的位置，也可以点击原来的位置跳过单位移动，直接进行攻击步骤。 

8 这将触发一个移动事件，tile当前行列的hasunit属性将会变为flase，unit属性将会为none，将要移动到的位置的tile的hasunit属性将会变为true，unit属性将会变为这次移动的单位。 

9 此时对棋盘进行一次刷新，单位的移动将会被显示在棋盘上。 

10 该棋子完成移动操作之后，可以进行攻击步骤。 

11 该棋子进入攻击步骤之后，将会根据攻击范围进行运用了广度优先搜索的寻路算法计算出可以攻击到的敌方单位并且显示在棋盘上，用高光表示，如果攻击范围内有嘲讽随从，那么你必须先攻击那个具有嘲讽的随从。 

12 玩家可以点击一个被高光表示出来的敌方单位进行攻击，或者双击当前的自己单位跳过攻击步骤。 

13 玩家在点击可以攻击到的敌方单位之后触发攻击事件。敌方被攻击到的单位的生命值将会被扣除你的攻击单位的攻击值。 

14 当敌方单位的生命值变化后大于0时，并且在玩家单位在敌方单位的攻击范围内（此时将会运用两个单位间的坐标进行计算）时，玩家的单位会受到反击。否则，敌方单位被摧毁。 

15 地方单位反击完成之后如果我方单位当生命值小于0时被摧毁。 

16 具有风怒的单位可以进行两次攻击步骤。 

17 完成后全部的攻击步骤之后，单位自动结束行动。 

18 结束回合时，此单位的active将会更改为FALSE。代表着在这个回合中不能再次行动。 

19 玩家继续选择下一个单位进行行动，直到没有单位可以行动为止。 

#### 玩家结束回合

1.当玩家点击endturn时，发送 "endturn"消息给后端

2.当后端收到玩家endturn消息时，调用对应类的proces函数，此函数应包括：

​	2.2将gamestate中playerturn置为false

​	2.1首先检查cardarraylist的size，当size <=6才进行更改，否则接着处理其他回合结束任务

​	2.2size<=6时，从卡池队列中出列一张卡牌对象，将其添加进cardarrylist，并使用drawcard函数在对应手牌槽区域绘制手牌

​	2.3将gamestate中AIrturn置为true

3.调用RoundCounter的nextRound()方法将回合数增加1 

4.玩家回合结束，进入ai回合 

5.调用AIPlaying中AIDecision()方法判断ai采取进攻还是防御，进攻调用AIAttack()，防御调用AIDefence() 

6.最后ai抽取一张新牌，调用AIEndTurn()结束ai回合，准备再次进入玩家回合 

### 3.结束游戏                                          
