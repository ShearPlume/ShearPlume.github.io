---
title: CSD-week1
date: 2023-02-23 02:23:49
tags:
- courses
- CSD
---

## 模数mod

#### 同余（符号是 $\equiv$）：

![image-20230122135726452](/CSD-week1/image-20230122135726452.png)

#### 逆元inverse

逆元其实是在群group里定义的：

![image-20230216121410908](/CSD-week1/image-20230216121410908.png)

![image-20230216121039918](/CSD-week1/image-20230216121039918.png)

ppt概念：

![image-20230118114110087](/CSD-week1/image-20230118114110087.png)

更易于理解的方式：
$$
ax \% n=1
$$
一个数可能有多个逆元但我们一般指最小的自然数

比如2\*4%7=1，2 \*11%7=1，我们认为2对7的逆元是4

##### 有逆元的条件：

**a** will have an inverse if and only if **gcd(a, n) = 1**

如果n是质数，那所有数除了0都对其有逆元

##### 模运算规则

![image-20230124095520179](/CSD-week1/image-20230124095520179.png)

![image-20230124095759695](/CSD-week1/image-20230124095759695.png)

##### The Homomorphism Theorem同态定理

同余具有下列**性质**：

如果*a*1  º  *b*1 (mod *m*)，*a*2  º  b2 (mod *m*)，则

1）*a*1+*a*2  º  *b*1+*b*2 (mod *m*)，

2）*a*1-*a*2  º  *b*1-*b*2 (mod *m*)，

3）*a*1*a*2  º  *b*1*b*2 (mod *m*)，

4）如果*ac* % *bc* (mod *m*)，且(*c*，*m*) = 1，则*a* º *b* (mod *m*)，

5）如果*a* º *b* (mod *m*)，且*d*½*m*，*d*是正整数，则*a* º *b* (mod *d*)．

##### 快速指数算法

(求 $a^b\  mod\  c$ ,==根据证明好像只有a<c的时候才能用？==)

例：求 $62^{65}(mod\ 133)$

要计算x的e次方对m取余的值，如果直接计算会数值会比较大，可以利用上面的模的性质进行降幂计算。

要计算 xe%m 的值 如 6265% 133 可以用如下的方法：

62^65 % 133
= 62 * 62^64 % 133
= 62 * (62^2)^^32 % 133
= 62 * 3844^32 % 133
= 62 * (3844 % 133)^32 % 133
= 62 * 120^32% 133

= 62 * 36^16 % 133
= 62 * 99^8 % 133
= 62 * 92^4 % 133
= 62 * 85^2 % 133
= 62 * 43 % 133
= 2666 % 133
= 6

##### 求a mod n的逆元方法：拓展欧几里得算法（辗转相除法）

###### 原版辗转相除法：

这个算法在《九章算术》当中曾经出现过，叫做更相减损术。不管叫什么，原理都是一样的，它的最核心本质是下面这个式子：
gcd(a,b)=gcd(b,r),a=bq+r

这个式子就是著名的欧几里得定理，这里的r可以看成是a对b取余之后的结果，也就是说==a和b的最大公约数等于b和r的最大公约数==。这样我们就把a和b的gcd转移成了b和r，然后我们可以继续转移，直到这两个数之间存在倍数关系的时候就找到了答案。

![image-20230124092458932](/CSD-week1/image-20230124092458932.png)

解释：由下往上推：$r_n$被 $r_{n-1}$ 整除，而 $r_{n-2}=q_{n-1}*q_n*r_n+r_n=r_n*(q_{n-1}*q_n+1)$ 所以 $r_{n-2}$ 也被 $r_{n}$ 整除，以此类推，$r_0 \ and\ r_1$ 都整除 $r_n$ 所以 $r_n$ 是他俩（a and b）的gcd

###### 扩展欧几里得算法：

![image-20230124093557822](/CSD-week1/image-20230124093557822.png)

#### Quiz:

1.Calculate 5 ^ 7 mod 11 by hand using repeated squaring and the  homomorphism theorem. (5 to the power 7 mod 11). Verify that the  calculations would be much harder if you left the mod 11 calculation to  the end. 

5^7 %11

=5*5^6%11

=5*25^3%11

=5*(25%11)^3%11

=5*3^3%11

=5\*3\*3^2%11

=((15%11)*(9%11))%11

=36%11

=3

2.Calculate 1 / 8 mod 11 (the inverse of 8) by hand using the equation  subtracting algorithm. Use your result to calculate 5 / 8 mod 11.

求8关于11的逆数：
$$
11*x \equiv 11\\

8*x\equiv1\\
3*x\equiv10\\
5*x\equiv-9\\
5*x\equiv2\\
2*x\equiv-8\\
2*x\equiv3\\
x\equiv7
inverse\ of\ 8\ mod\ =7
$$
验证：8*7 % 11=1

5*7=35

## 异或 XOR

#### 用途1：模拟多项式算数

基于整数模2，因为0和1的加减法和异或性质相同

0+0=0,	 0-0=0, 	0^0=0 

0+1=1, 	0-1=-1=1, 	0^1=1 

1+0=1, 	1-0=1,	 1^0=1 

1+1=2=0, 	1-1=0,	 1^1=0

#### 用途2：使某些特定的位翻转

例如对数10100001的第2位和第3位翻转，则可以将该数与00000110进行按位异或运算。

　　10100001^00000110 = 10100111

#### 用途3：实现两个值的交换而不使用第三个变量

例如交换两个整数a=10100001，b=00000110的值，可通过下列语句实现：

　　a = a^b； 　　//a=10100111

　　b = b^a； 　　//b=10100001	==(b=b\^a\^b=a^0=a)==

　　a = a^b； 　　//a=00000110	==(a=a\^b\^a=b^0=b)==

## 多项式算术 Polynomial Arithmetic

### 域

域有这样一个性质：在加法和乘法上具有封闭性。也就是说对域中的元素进行加法或乘法运算后的结果仍然是域中的元素。有一点要注意，域里面的乘法和加法不一定是我们平常使用的乘法和加法。可以把C语言中的与运算和异或运算分别定义成加法和乘法。但习惯上，仍然使用符号+ 和 * 表示加法和乘法运算。
 域有单位元和逆元两个概念。

   加法和乘法运算都有对应的单位元(这两个单位元一般不同，但都用符号e表示)。单位元就像线性代数的单位矩阵。一个矩阵乘以单位矩阵等于本身。对应地，在域中的单位元有：对于加法单位元，所有元素加上单位元e，等于其本身。对应乘法单位元，所有元素乘上单位e，等于其本身。

逆元就像数学上的倒数，两个元素互为对方的逆元。如果==元素a和b互为加法逆元==，那么就有 ==a + b = e==。若互为乘法逆元，那么就有a * b = e。如果元素a在域中找不到另外一个元素b，使得a+b=e(a*b=e)，那么a就没有加法(乘法)逆元。

逆元有什么用呢？其实逆元是用于除法运算的。小学的时候老师都会教：除于一个分数就等于乘以该分数的倒数(分数的倒数就是该分数的乘法逆元)。所以要想除于某个数，可以乘以该数的逆元。

一个集合有加法单位元和乘法单位元，以及每一个元素都对应有加法逆元和乘法逆元，是成为域的必要条件。需要注意：即使集合里面有元素0，并且0没有对应的乘法逆元，那么该集合也可能是一个域。因为并不要求0有乘法逆元。

​     一个域的例子就是我们平时熟悉的有理数集合，相应的加法和乘法就是我们平时用的加法和乘法。其中，加法的单位元为0，有理数a的加法逆元就是其相反数。因为a + (-a) = 0(单位元)。乘法的单位元为1，a的乘法逆元是其倒数。因为a * (1/a) = 1。注意这里的元素0并没有乘法逆元。



### 有限域GF（p）：

有限意思是域中元素个数是有限的

GF(p)就是mod p，因为一个数 模p后，结果在[0, p-1]之间。对于元素a和b，那么(a+b) mod p和(a*b)mod p，其结果都是域中的元素。GF(p)里面的加法和乘法都是平时用的加法和乘法。GF(p)的加法和乘法单位元分别是0和1，元素的加法和乘法逆元都很容易理解和求得

### 有限域GF(2^8)：

 现在重点讲一下GF(2^n)，特别是GF(2^8)，因为8刚好是一个字节的比特数。

前面说到， GF(p)，p得是一个素数，才能保证集合中的所有元素都有加法和乘法逆元(0除外)。但我们却很希望0到255这256个数字也能组成一个域。因为很多领域需要用到。mod 256的余数范围就是0到255，但256不是素数。小于256的最大素数为251，所以很多人就直接把大于等于251的数截断为250。在图像处理中，经常会这样做。但如果要求图像无损的话，就不能截断。

貌似已经到了死胡同，救星还是有的，那就是GF(p^n^)，其中p为素数。在这里我们只需令p为2，n为8，即GF(2^8)。

### 多项式：

► 一个多项式涉及$x, x^2 , x^3$等项。 

​	o 我们对实际计算x不感兴趣。

​	o 我们只是想使用多项式算术来产生新的多项式。 

► 我们对一种特殊形式的多项式感兴趣，其中x的幂的==系数是整数模2==。(要么是1要么是0) 

► 所以一个典型的多项式将是$1 + x^2 + x^5$ 

► 或者，写成全称: $1 + 0*x + 1*x^2 + 0*x^3 + 0*x^4 + 1*x^5 + 0*x6 ...$

### 比特串和多项式

#### 群，环的关系图：

![img](../CSD-week1/70)

从一个位串转换到这些多项式之一是非常容易的。 

► 这些位，从最低位开始，是x的幂的系数。
$$
x^2/a^2+y^2/b^2=1
$$
$1101_2 → x^3 + x^2 + 1$ 

► 换回也很简单

$x^3 + x^2 + 1→ 1101_2 $  

► 加密和解密操作的+, -, * , % 操作，可以用多项式算术完成,在GF(2)中，模2的加法和减法是等价的，==加法等价于XOR运算，乘法等价于逻辑与运算==

​	加法和减法是直截了当的。 二者是一样，都是异或(XOR)，两个多项式加法等同于按位异或运算

$1 + x^2 + x^3  + x + x^3 = 1 + x + x^2$	($x^3\oplus x^3=0$)

​	乘法也很简单，但会导致更大的多项式。

简单的异或运算不能完成GF($2^n$)上的乘法。但是可以使用一种相当直观且容易实现的技巧。
一般地，在GF($2^n$)上对于n次多项式p(x)，有$x^n$ mod p(x) =p(x)-$x^n$。

![image-20230216120232189](/CSD-week1/image-20230216120232189.png)
$$
(1+x^2+x^3)(x+x^3) =(x+x^3+x^4)+(x^3+x^5+x^6)=x+x^3+x^3+x^4+x^5+x^6=x+x^4+x^5+x^6
$$

$$
（1101）（1010）=
$$



## 除后的余数

► 我们可以通过将一个多项式除以另一个多项式后的余数来减少乘法产生的多项式的大小。
	与整数mod n的技巧相同。
► 如果我们希望最高次幂是x^3^，那么我们用最高次幂x^4^的多项式进行除法。

![image-20230221091139234](/CSD-week1/image-20230221091139234.png)

► 多项式除法是复杂的，即使在高中数学中被教授。
► 使用基于整数模2的多项式要容易得多!

## "质数"多项式

素多项式。其定义和素数类似，素多项式==不能表示为其他两个多项式相乘的乘积==。

► 一些多项式是 "素数"。
 它们不能被写成更小的多项式的因子。
 它们被称为不可简化的多项式。
► 如果我们对一个不可还原的多项式做多项式算术，那么所有的多项式将有逆。
► 一些不可还原的多项式。
3位数: x3 + x + 1
4位数： x4 + x + 1
6位数： x6 + x + 1
8位数：x8 + x4 + x3 + x + 1

重点：指数小于n的多项式对n次素多项式取模会形成一个域

（就像小于素数的数对素数取模会得到一个域一样）

==注意，这些逆元都是和素多项式相关的，同一个多项式，取不同的素多项式，就有不同的逆元多项式。==

==由素多项式得到的域，其加法单位元都是0，乘法单位元是1。==

   前面讲到了对素多项式取模，然后可以得到一个域。但这和最初的目的有什么关系吗？多项式和0， 1， ……，255没有什么关系。确实是没有什么关系，但多项式的系数确可以组成0， 1， 2，……255这些数。回到刚才的GF(2^3),对应的8个多项式，其系数刚好就是000,001, 010, 011, 100, 101, 110, 111。这不正是0到7这8个数的二进制形式吗？也就是说，它们有一一对应映射的关系。多项式对应一个值，我们可以称这个值为多项式值。
	对于GF(2^3^)，取素多项式为x^3^ + x+1，那么多项式x^2^+x的乘法逆元就是x+1。

(x^3^+x+1)*(x^2^+x)mod( 素多项式)=1

系数对应的二进制分别为110和011。此时，我们就认为对应的十进制数6和3互为逆元。即使mod 8不能构成一个域，但通过上面的对应映射，0到7这8个数一样有对应逆元了(为了顺口，说成0到7。实际0是没有乘法逆元的)。同样，对于GF(2^8)也是一样的。所以0到255，这256个数都可以通过这样的方式得到乘法逆元(同样，0是没有乘法逆元的)。
